{"ast":null,"code":"/* global define, Promise */\n(function (root, factory) {\n  'use strict';\n\n  if (typeof module === 'object' && module.exports && typeof require === 'function') {\n    // CommonJS\n    module.exports = factory();\n  } else if (typeof define === 'function' && typeof define.amd === 'object') {\n    // AMD. Register as an anonymous module.\n    define(factory);\n  } else {\n    // Browser globals\n    root.Queue = factory();\n  }\n})(this, function () {\n  'use strict';\n  /**\n   * @return {Object}\n   */\n\n  var LocalPromise = typeof Promise !== 'undefined' ? Promise : function () {\n    return {\n      then: function () {\n        throw new Error('Queue.configure() before use Queue');\n      }\n    };\n  };\n\n  var noop = function () {};\n  /**\n   * @param {*} value\n   * @returns {LocalPromise}\n   */\n\n\n  var resolveWith = function (value) {\n    if (value && typeof value.then === 'function') {\n      return value;\n    }\n\n    return new LocalPromise(function (resolve) {\n      resolve(value);\n    });\n  };\n  /**\n   * It limits concurrently executed promises\n   *\n   * @param {Number} [maxPendingPromises=Infinity] max number of concurrently executed promises\n   * @param {Number} [maxQueuedPromises=Infinity]  max number of queued promises\n   * @constructor\n   *\n   * @example\n   *\n   * var queue = new Queue(1);\n   *\n   * queue.add(function () {\n   *     // resolve of this promise will resume next request\n   *     return downloadTarballFromGithub(url, file);\n   * })\n   * .then(function (file) {\n   *     doStuffWith(file);\n   * });\n   *\n   * queue.add(function () {\n   *     return downloadTarballFromGithub(url, file);\n   * })\n   * // This request will be paused\n   * .then(function (file) {\n   *     doStuffWith(file);\n   * });\n   */\n\n\n  function Queue(maxPendingPromises, maxQueuedPromises, options) {\n    this.options = options = options || {};\n    this.pendingPromises = 0;\n    this.maxPendingPromises = typeof maxPendingPromises !== 'undefined' ? maxPendingPromises : Infinity;\n    this.maxQueuedPromises = typeof maxQueuedPromises !== 'undefined' ? maxQueuedPromises : Infinity;\n    this.queue = [];\n  }\n  /**\n   * Defines promise promiseFactory\n   * @param {Function} GlobalPromise\n   */\n\n\n  Queue.configure = function (GlobalPromise) {\n    LocalPromise = GlobalPromise;\n  };\n  /**\n   * @param {Function} promiseGenerator\n   * @return {LocalPromise}\n   */\n\n\n  Queue.prototype.add = function (promiseGenerator) {\n    var self = this;\n    return new LocalPromise(function (resolve, reject, notify) {\n      // Do not queue to much promises\n      if (self.queue.length >= self.maxQueuedPromises) {\n        reject(new Error('Queue limit reached'));\n        return;\n      } // Add to queue\n\n\n      self.queue.push({\n        promiseGenerator: promiseGenerator,\n        resolve: resolve,\n        reject: reject,\n        notify: notify || noop\n      });\n\n      self._dequeue();\n    });\n  };\n  /**\n   * Number of simultaneously running promises (which are resolving)\n   *\n   * @return {number}\n   */\n\n\n  Queue.prototype.getPendingLength = function () {\n    return this.pendingPromises;\n  };\n  /**\n   * Number of queued promises (which are waiting)\n   *\n   * @return {number}\n   */\n\n\n  Queue.prototype.getQueueLength = function () {\n    return this.queue.length;\n  };\n  /**\n   * @returns {boolean} true if first item removed from queue\n   * @private\n   */\n\n\n  Queue.prototype._dequeue = function () {\n    var self = this;\n\n    if (this.pendingPromises >= this.maxPendingPromises) {\n      return false;\n    } // Remove from queue\n\n\n    var item = this.queue.shift();\n\n    if (!item) {\n      if (this.options.onEmpty) {\n        this.options.onEmpty();\n      }\n\n      return false;\n    }\n\n    try {\n      this.pendingPromises++;\n      resolveWith(item.promiseGenerator()) // Forward all stuff\n      .then(function (value) {\n        // It is not pending now\n        self.pendingPromises--; // It should pass values\n\n        item.resolve(value);\n\n        self._dequeue();\n      }, function (err) {\n        // It is not pending now\n        self.pendingPromises--; // It should not mask errors\n\n        item.reject(err);\n\n        self._dequeue();\n      }, function (message) {\n        // It should pass notifications\n        item.notify(message);\n      });\n    } catch (err) {\n      self.pendingPromises--;\n      item.reject(err);\n\n      self._dequeue();\n    }\n\n    return true;\n  };\n\n  return Queue;\n});","map":{"version":3,"sources":["C:/website/node_modules/promise-queue/lib/index.js"],"names":["root","factory","module","exports","require","define","amd","Queue","LocalPromise","Promise","then","Error","noop","resolveWith","value","resolve","maxPendingPromises","maxQueuedPromises","options","pendingPromises","Infinity","queue","configure","GlobalPromise","prototype","add","promiseGenerator","self","reject","notify","length","push","_dequeue","getPendingLength","getQueueLength","item","shift","onEmpty","err","message"],"mappings":"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","sourcesContent":["/* global define, Promise */\n(function (root, factory) {\n    'use strict';\n    if (typeof module === 'object' && module.exports && typeof require === 'function') {\n        // CommonJS\n        module.exports = factory();\n    } else if (typeof define === 'function' && typeof define.amd === 'object') {\n        // AMD. Register as an anonymous module.\n        define(factory);\n    } else {\n        // Browser globals\n        root.Queue = factory();\n    }\n})\n(this, function () {\n    'use strict';\n\n    /**\n     * @return {Object}\n     */\n    var LocalPromise = typeof Promise !== 'undefined' ? Promise : function () {\n        return {\n            then: function () {\n                throw new Error('Queue.configure() before use Queue');\n            }\n        };\n    };\n\n    var noop = function () {};\n\n    /**\n     * @param {*} value\n     * @returns {LocalPromise}\n     */\n    var resolveWith = function (value) {\n        if (value && typeof value.then === 'function') {\n            return value;\n        }\n\n        return new LocalPromise(function (resolve) {\n            resolve(value);\n        });\n    };\n\n    /**\n     * It limits concurrently executed promises\n     *\n     * @param {Number} [maxPendingPromises=Infinity] max number of concurrently executed promises\n     * @param {Number} [maxQueuedPromises=Infinity]  max number of queued promises\n     * @constructor\n     *\n     * @example\n     *\n     * var queue = new Queue(1);\n     *\n     * queue.add(function () {\n     *     // resolve of this promise will resume next request\n     *     return downloadTarballFromGithub(url, file);\n     * })\n     * .then(function (file) {\n     *     doStuffWith(file);\n     * });\n     *\n     * queue.add(function () {\n     *     return downloadTarballFromGithub(url, file);\n     * })\n     * // This request will be paused\n     * .then(function (file) {\n     *     doStuffWith(file);\n     * });\n     */\n    function Queue(maxPendingPromises, maxQueuedPromises, options) {\n        this.options = options = options || {};\n        this.pendingPromises = 0;\n        this.maxPendingPromises = typeof maxPendingPromises !== 'undefined' ? maxPendingPromises : Infinity;\n        this.maxQueuedPromises = typeof maxQueuedPromises !== 'undefined' ? maxQueuedPromises : Infinity;\n        this.queue = [];\n    }\n\n    /**\n     * Defines promise promiseFactory\n     * @param {Function} GlobalPromise\n     */\n    Queue.configure = function (GlobalPromise) {\n        LocalPromise = GlobalPromise;\n    };\n\n    /**\n     * @param {Function} promiseGenerator\n     * @return {LocalPromise}\n     */\n    Queue.prototype.add = function (promiseGenerator) {\n        var self = this;\n        return new LocalPromise(function (resolve, reject, notify) {\n            // Do not queue to much promises\n            if (self.queue.length >= self.maxQueuedPromises) {\n                reject(new Error('Queue limit reached'));\n                return;\n            }\n\n            // Add to queue\n            self.queue.push({\n                promiseGenerator: promiseGenerator,\n                resolve: resolve,\n                reject: reject,\n                notify: notify || noop\n            });\n\n            self._dequeue();\n        });\n    };\n\n    /**\n     * Number of simultaneously running promises (which are resolving)\n     *\n     * @return {number}\n     */\n    Queue.prototype.getPendingLength = function () {\n        return this.pendingPromises;\n    };\n\n    /**\n     * Number of queued promises (which are waiting)\n     *\n     * @return {number}\n     */\n    Queue.prototype.getQueueLength = function () {\n        return this.queue.length;\n    };\n\n    /**\n     * @returns {boolean} true if first item removed from queue\n     * @private\n     */\n    Queue.prototype._dequeue = function () {\n        var self = this;\n        if (this.pendingPromises >= this.maxPendingPromises) {\n            return false;\n        }\n\n        // Remove from queue\n        var item = this.queue.shift();\n        if (!item) {\n            if (this.options.onEmpty) {\n                this.options.onEmpty();\n            }\n            return false;\n        }\n\n        try {\n            this.pendingPromises++;\n\n            resolveWith(item.promiseGenerator())\n            // Forward all stuff\n                .then(function (value) {\n                    // It is not pending now\n                    self.pendingPromises--;\n                    // It should pass values\n                    item.resolve(value);\n                    self._dequeue();\n                }, function (err) {\n                    // It is not pending now\n                    self.pendingPromises--;\n                    // It should not mask errors\n                    item.reject(err);\n                    self._dequeue();\n                }, function (message) {\n                    // It should pass notifications\n                    item.notify(message);\n                });\n        } catch (err) {\n            self.pendingPromises--;\n            item.reject(err);\n            self._dequeue();\n\n        }\n\n        return true;\n    };\n\n    return Queue;\n});\n"]},"metadata":{},"sourceType":"script"}